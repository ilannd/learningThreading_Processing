# 之前讲过共享全局变量 global A,放在多线程里面
# 但是在多进程中，全局变量A分给每一个CPU，每个CPU 计算这个A，交流这个A是行不通的
# 因为 多线程可以做到共享全局变量，但是多进程由于资源相互独立，多进程中修改的变量是无法给外部访问的

# 提出了共享内存
# 共享内存，主要是实现进程间大量数据的传输。所谓共享内存，即在内存中开辟一段特殊的内存空间，多个进程可互斥访问，该内存空间具有自身特有的数据结构。
#
# 多个进程在使用此共享内存空间时候，必须在进程地址空间与共享内存地址空间之间建立连接，即将共享内存空间挂载到进程中；
# 共享内存是由一个进程开辟，其它任何进程都可以挂载；
# 共享内存并不会随着进程的退出而消失，因此最后不使用此内存空间时，必须要手动删除

import multiprocessing as mp
import time

# python的multiprocessing模块也给我们提供了共享内存的操作
'''

# 定义共享内存，给每一个CPU 每一个核读写
# 只能用共享内存，才能进行CPU或核之间的一个交流

value = mp.Value('i', 1)
# 'i'代表整数，'d'代表小数，'c'代表字符

# 或者
array = mp.Array('i', [1, 3, 4])

'''


def job(v, num, l):
    l.acquire()
    for _ in range(10):
        time.sleep(0.1)
        v.value += num
        print(v.value)
    l.release()


def multicore():
    l = mp.Lock()
    v = mp.Value('i', 0)
    p1 = mp.Process(target=job, args=(v, 1, l))
    p2 = mp.Process(target=job, args=(v, 3, l))
    p1.start()
    p2.start()
    p1.join()
    p2.join()


if __name__ == '__main__':
    multicore()

# 没加锁的运行结果，p1和p2会交替对共享内存进行操作，乱套了
# 1
# 1
# 4
# 5
# 6
# 9
# 12
# 13
# 14
# 17
# 20
# 21
# 22
# 25
# 26
# 29
# 32
# 33
# 36
# 36

# 加了锁之后的运行结果，先是p1对共享内存进行操作，p2基于内存的结果再进行操作
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 10
# 13
# 16
# 19
# 22
# 25
# 28
# 31
# 34
# 37
# 40
